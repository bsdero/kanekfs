#ifndef _SLOT_STG_H_
#define _SLOT_STG_H_

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "slots.h"

#define NEFS_MAGIC                               0xbadd0d0  
#define NEFS_BLOCK_SIZE                          8192


/* All the metadata for nodes and edges in the graph are stored in 
 * "key-values" and organized in "slots". For this effect, each slot has a 
 * unique ID -which for our purposes is a sequencial unsigned integer-, and 
 * an array of key-values -which I will call, a dictionary-, like this:
 *  ----------------------------------------------------------------------
 *    SLOT 0: [ key1=value1, k2=myval ]
 *    SLOT 1: []
 *    SLOT 2: [ mykey=0, publickey="8w09cfw432f09", distance=32.6435
 *    SLOT 3: [ mount_host29d9i3="{n:32:localhost:97}", lock="ef4987s2" ]
 *    SLOT 4: [ Editor="armando" ]
 *  ----------------------------------------------------------------------
 *  I am familiar with python, so basically we have an array of dictionaries
 *  here. So, the next data structures provides an on-disk representation 
 *  for store this data. 
 *
 * For ease of locate for empty slots, a slot index is provided. 
 * Once a slot is located in the slot index, the slot dictionary can be 
 * read, updated or removed. 
 *
 */

/* kfs_metadata_descriptor_t is a data structure on disk, which keeps all the 
 * details of the slots -dictionaries- stored.
 * It should allow:
 *   -Creation and population into dictionaries slots
 *   -Read data from slots
 *   -Updates of data in slots
 *   -Deletion of data in slots 
 */
typedef struct{
    uint32_t kfs_magic;

#define NEFS_META_MAGIC                            0xb1b1d1
    uint32_t meta_magic;

    uint64_t slots_count;        /* slots capacity */
    uint64_t slots_in_use;      

    /* the next two fields points to a kfs_slots_index_descriptor_t
     * structure on disk. */
    uint64_t slots_index_block;  /* points to the first index block. 
                                    If is 0, the slots index starts on 
                                    this block and slots_index_offset 
                                    has the start address of the index 
                                    offset*/
    uint64_t slots_index_offset; /* points to the first index descriptor,
                                    which is in this block */
    
    uint64_t bmap_extent;        /* points to the block map */ 
    uint64_t bmap_count;         /* how many blocks are used */
}kfs_metadata_descriptor_t;


/* kfs_slots_index_descriptor_t descripts an index to locate 
 * slots/dictionaries data easily. One descriptor per block is expected, and
 * we can know how many slots are stored on this block, how many are free and 
 * where is the data. 
 *
 * Slots are added on demand and also the index. 
 * Each block should have an index descriptor. */
typedef struct{ 
    uint32_t kfs_magic;

    #define NEFS_SLOTS_NDX_MAGIC                   0xbab1d1
    uint32_t slots_ndx_magic;


    uint32_t slots_capacity; /* how many slots we have here */
    uint32_t slots_seq;      /* from which seq number we are starting */
    uint32_t slots_in_use;   /* used slots in this block */
    uint64_t next_block;     /* next block. if 0, this is terminator 
                                ( no more blocks for index) */
}kfs_slots_index_descriptor_t;


/* Right after the location of a kfs_slots_index_descriptor_t, a lot of 
 * structures kfs_slots_index_entry_t should be stored. These data 
 * structures stores the actual location of the dictionary and the slot owner 
 */
typedef struct{ /* entry for the slots index. This structure helps to locate
                   slot data faster */
    uint64_t slot_id;     /* slot ID. Should be stored in sequence. */
    uint64_t slot_block;  /* block with this slot entries. Points to
                             a block with a 
                             kfs_slots_descriptor_header_t
                             structure */
    owner_u owner;        /* owner of this slot */
    uint32_t flags;       /* the same flags than in slots.h in slot_t*/
kfs_slots_index_entry_t;



typedef struct{
    uint64_t slot_id;  /* slot ID */
    uint16_t total_blocks;    /* total of blocks for this slot */
    uint16_t data_block_seq;  /* which block of the total is this one */ 
    uint16_t total_elems;  /* total number of elements in the slot */ 
    uint16_t num_elems; /* number of elements for this slot in this block */
    uint16_t elems_seq; /* sequence number for the first element  
                           in this block */

    uint16_t data_offset;  /* offset in bytes to the first kv pair of this 
                              block. In that place, a kfs_slot_data_t 
                              should be found */

    uint16_t data_len; /* how many data bytes are used for this slot in this
                          block. We need this to calculate how many free 
                          space do we have */
    uint16_t spare_flags; /* extra room */
    uint64_t next_block; /* points to the next kfs_slots_descriptor_header 
                            block with kv pairs belonging to this slot_id. 
                            If 0, this block is a terminator for this slot, 
                            mean, all the data for this slot is stored in 
                            this block */
}kfs_slot_descriptor_t;


typedef struct{
    uint32_t kfs_magic;
    #define NEFS_SLOTS_DATABLOCK_MAGIC            0xb00000
    uint32_t magic;
    uint32_t slots_num;  /* number of slots on this block. */
}kfs_slots_descriptor_header_t;
/* after this header, an array of kfs_slots_descriptor_t data structures 
 * should be located. 
 */

typedef struct{
    uint8_t rec_len;    /* this record size */
    uint8_t key_len;    /* key size */
    uint8_t value_type; /* value data type */
    uint8_t value_len;  /* value data length */
    uint16_t next_key;  /* offset to the next key. if 0, this is the 
                          terminator. if 0xffffffff, continues in other 
                          block */

    uint64_t hash_k;   /* hash for key */
    char kv_data[];    /* this field should be a blob with a 
                          zero terminated string, which is the key, followed
                          immediately with the 
                          value data */

}kfs_slot_data_t;

int slots_create( char *fname, uint64_t slots_num);
int slots_open( char *fname);
int slots_close( int md);
int slots_resize( int md, uint64_t slots_num);
int slot_reserve(int md);
sltable_t *slots_read( int md, int slot_id, int slots_num);
int slots_update( int md, sltable_t *slots);
int slot_delete( int md, uint64_t slot_id);
int slot_update( int md, uint64_t slot_id, slot_t s);

#endif

